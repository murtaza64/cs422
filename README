1. Murtaza Javaid and Daniel Li
2. Coded together
3. 
    Part 1: Created thread sleep and wake up functions to allow threads to wait on resources using the lk.
    Thread sleep acquires the required locks, sets the old pids state to sleeping and waits until the 
    resource is available, switches context with the next thread and marks it as running, then releases the required locks.
    Thread yield manually puts the old thread back onto the ready queue and sets the next thread from the ready queue
    as running. We also used the scheduler lock in this code for concurrency. 

    Part 2: N/A

    Part 3:
        - Directory Layer: Implemented dir_lookup to find a subdirectory inode in a given directory, also implemented dir_link, which links a new inode to the existing current directory inode.
        - Path Layer: Implemented a skipelem function to copy the name of the first directory to "name" and returns the new path without the first directory. Also implemented namex
        which looks up and return the inode for a path name, or 0 if it fails.
        - Syscall Layer: Modified the syscall functions to pass in strlen through inline assembly arguments. Implemented the fdalloc, sys_read, sys_write, sys_close and sys_fstat functions while adding error checking.

    Part 4:
        - ls: Use [ls] to list subdirectories in current directory, or, can pass in a directory as an extra argument to 
        list subdirectories in specified directory [ls dir_name]
        - pwd: prints the current directory path [pwd]
        - cd: change directory to current using . [cd .] as argument or previous directory using .. [cd ..]
        - cp: copy file from source to destination: [cp source dest] can use the -r
        argument to copy a folder [cp -r source dest]. Recursive copy overwrites file in destination folder
        if they have the same name as files in the source folder. Checks are done to ensure that the destination is a directory
        and source is either file if called regularly and directory if called with -r.
        - mv: move file or directory from source to destination: [mv source destination]
        - rm: remove a file using [rm filepath] or directory by using [rm -r directorypath]
        - mkdir: makes a directory in current directory using [mkdir directory name]
        - cat: output the contents of a specific file, checks are done to ensure the file 
        exists, and a directory is not passed in. [cat filename]
        - touch: create a file in current directory using [touch filename]
        - writestr: write a string to a file, will create a new file if the file did not exist
        or overwrite the exisiting file contents. [writestr "string to write" destfile]
        - appendstr: append a string to a file, will check to see if the file exists first and throws
        an error if it does not exist. Will append string to the file existing contents.
        [appendstr "string to append" destfile]


    Testing output:

    Welcome to ckosh!
    $ mkdir d1
    $ touch file.txt
    $ writestr "hello" file.txt
    $ cat file.txt
    hello
    $ mv file.txt d1
    mv: file.txt -> d1/file.txt
    $ appendstr " world!" d1/file.txt
    $ cat d1/file.txt
    hello world!
    $ mkdir d1/d11
    $ cp d1/file.txt d1/d11/file2.txt
    cp: d1/file.txt -> d1/d11/file2.txt
    $ cp -r d1 d2
    cp: d1/file.txt -> d2/file.txt
    cp: d1/d11/ -> d2/d11/
    cp: d1/d11/file2.txt -> d2/d11/file2.txt
    $ ls d1
    ./
    ../
    file.txt
    d11/
    $ ls d2
    ./
    ../
    file.txt
    d11/
    $ ls
    ./
    ../
    README
    d1/
    d2/
    $ mkdir d3
    $ mv d2 d3/d1
    mv: d2 -> d3/d1
    $ ls d3
    ./
    ../
    d1/
    $ rm -r d3/d1/d11
    rm: unlink d3/d1/d11/file2.txt
    rm: unlink d11 from parent
    $ touch d3/d1/d11
    $ cp -r d1 d3
    cp: d1/file.txt -> d3/d1/file.txt (overwrite)
    cp: skipping d1/d11/ -> d3/d1/d11/ as d3/d1/d11 is not a directory
    $ cp -r d1 d4
    cp: d1/file.txt -> d4/file.txt
    cp: d1/d11/ -> d4/d11/
    cp: d1/d11/file2.txt -> d4/d11/file2.txt
    $ mkdir d5
    $ mv d4 d5
    mv: d4 -> d5/d4
    $ touch d1/file2.txt
    $ mkdir d1/d12
    $ mv d5/d4 d5/d1
    mv: d5/d4 -> d5/d1
    $ cp -r d1 d5/d
    cp: d1/file.txt -> d5/d1/file.txt (overwrite)
    cp: d1/d11/ -> d5/d1/d11/ (merge)
    cp: d1/d11/file2.txt -> d5/d1/d11/file2.txt (overwrite)
    cp: d1/file2.txt -> d5/d1/file2.txt
    cp: d1/d12/ -> d5/d1/d12/
    $

4. N/A